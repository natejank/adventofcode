#!/usr/bin/env python3
# TODO:
# clean (no args) to rm -r out/*
# compile (no args) to recursively compile the whole project
# autodetect which language to use for a given day
import argparse
import sys
import subprocess
from pathlib import Path

BUILD_DIR = 'out'
COMPILE_FLAGS = ('-d', BUILD_DIR)
RUN_FLAGS = ('-classpath', BUILD_DIR)
PACKAGE = 'net.sloshy.aoc'
JAVA_SOURCE_FOLDER = Path('src', 'java')
PYTHON_SOURCE_FOLDER = Path('src', 'python')


def find_java_files(source_root=JAVA_SOURCE_FOLDER) -> list[Path]:
    """
    Finds all java files from a given root

    :param source_root: root of search, default src/java
    :return: all java files from a starting point

    See Also
    ---
    find_source_files
    """
    return find_source_files(source_root, '*.java')


def find_python_files(source_root=PYTHON_SOURCE_FOLDER):
    """
    Finds all python files from a given root

    :param source_root: root of search, default src/python
    :return: all java files from a starting point

    See Also
    ---
    find_source_files
    """
    return find_source_files(source_root, '*.py')


def find_source_files(source_root: Path, extension: str) -> list[Path]:
    """
    Recursively crawls filesystem from a root to find source files.

    :param extension:
    :param source_root: the root to crawl from
    :return: list of paths to java files, with source_root as the start of the path
    """
    paths = [source_root]
    files = []
    while len(paths) > 0:
        directory = paths.pop(0)
        for path in directory.iterdir():
            if path.is_dir() and path not in paths:
                paths.append(path)
        for file in directory.glob(extension):
            if file not in files:
                files.append(file)
    return files


def compile_java(*files: Path) -> bool:
    """
    Compiles java files given as arguments

    :param files: string paths to compile
    """
    # convert path to string before compilation
    to_compile = [str(f) for f in files]
    outcome = subprocess.run(['javac', *COMPILE_FLAGS, *to_compile])
    return outcome.returncode == 0


def get_input_path(year: str, day: str, test: bool) -> Path:
    """
    Gets the path to the input file.  Input files are stored in
    lib/{year}/day{day}.input.txt, so this method returns a path to the input
    in that form.

    :param year: 2-digit year
    :param day: day to get
    :param test: whether to get the test input
    :return: path to a given day's input
    """
    return Path('lib', f'20{year}', f'day{day}{"_test" if test else ""}.input.txt')


def get_class(year: str, day: str) -> Path:
    """
    Gets a filesystem path to a java class.  This is useful for accessing
    compiled class files in the output directory

    :param year: year of class
    :param day: day of class
    :return: Path to class file
    """
    return Path(*PACKAGE.split('.')).joinpath(f'x{year}').joinpath(f'Day{day}')


def get_python_file(year: str, day: str) -> Path:
    """
    Gets a filesystem path to a python executable.

    :param year: year of file
    :param day: day of file
    :return: path to executable
    """
    return PYTHON_SOURCE_FOLDER.joinpath(f'x{year}').joinpath(f'day{day}.py')


def run_java(year: str, day: str, input_file) -> None:
    """
    Runs java class for a given year and day

    :param year: year to run
    :param day: day to run
    :param input_file: input file to provide; Path or str
    """
    res = compile_java(*find_java_files())
    if res:
        path = get_class(year, day)
        subprocess.run(['java', *RUN_FLAGS, str(path), str(input_file)])
    else:
        print('Java compilation failed!')


def run_python(year: str, day: str, input_file) -> None:
    """
    Runs a python file for a given year and day

    :param year: year to run
    :param day: day to run
    :param input_file: input file to provide; path or str
    """
    path = get_python_file(year, day)
    subprocess.run([sys.executable, str(path), str(input_file)])


def java_template(year: str, day: str) -> None:
    """
    Templates a java source file for a given year and day.  The package for
    the year must already exist.

    :param year: year to create
    :param day: day to create
    """
    template = (
        f'package {PACKAGE}.x{year};\n',
        '\n',
        'import java.util.*;\n',
        '\n',
        f'import {PACKAGE}.common.Utilities;\n',
        '\n',
        f'public class Day{day} {{\n',
        '    public static void main(String[] args) {\n'
        '        \n'
        '    }\n'
        '}\n'
    )
    input_file = str(JAVA_SOURCE_FOLDER.joinpath(get_class(year, day)).with_suffix('.java'))

    with open(input_file, 'w') as handle:
        handle.writelines(template)


def main() -> None:
    # set up cli interface
    argument_parser = argparse.ArgumentParser(description='An advent of code build system')
    argument_parser.add_argument('directive', help='Run directive.  Possible options are [run, create]')
    argument_parser.add_argument('year', help='Year to run. Valid formats are 4 digit (2022) or 2 digit (22)')
    argument_parser.add_argument('day', help='Day to run')
    argument_parser.add_argument('--test', '-t', dest='test', action='store_true', help='Use the test input?')
    argument_parser.add_argument('--python', '-p', dest='use_python', action='store_true',
                                 help='Run the python implementation for a given day?')
    argument_parser.add_argument('--java', '-j', dest='use_java', action='store_true',
                                 help='Run the java implementation for a given day?')
    argument_parser.add_argument('--input', '-i', dest='input_file', help='Custom input file')

    args = argument_parser.parse_args()
    year = args.year
    day = args.day
    if args.use_python:
        language = 'PYTHON'
    else:
        language = 'JAVA'

    # truncate year to 2 digits
    if len(year) > 2:
        year = year[2:]

    # find input file
    if args.input_file is not None:
        input_file = args.input_file
    else:
        input_file = get_input_path(year, day, args.test)

    match args.directive:
        case 'run':
            match language:
                case 'JAVA': run_java(year, day, input_file)
                case 'PYTHON': run_python(year, day, input_file)
        case 'create':
            get_input_path(year, day, False).touch()
            get_input_path(year, day, True).touch()
            # templating
            match language:
                case 'JAVA': java_template(year, day)
        case _:
            print('Invalid directive!')
            sys.exit(1)


if __name__ == '__main__':
    main()
